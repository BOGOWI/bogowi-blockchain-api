name: Deploy Go API to EC2

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: eu-central-1
  GO_VERSION: "1.23"

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Download dependencies
      run: go mod download
    
    - name: Run tests
      run: go test -v ./...
    
    - name: Run vet
      run: go vet ./...
    
    - name: Check formatting
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code is not formatted:"
          gofmt -s -l .
          exit 1
        fi

  build:
    name: Build Binary
    runs-on: ubuntu-latest
    needs: test
    timeout-minutes: 15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Download dependencies
      run: go mod download
    
    - name: Build for Linux
      env:
        CGO_ENABLED: 0
        GOOS: linux
        GOARCH: amd64
      run: |
        go build -a -installsuffix cgo -ldflags '-extldflags "-static"' -o bogowi-api-linux .
        chmod +x bogowi-api-linux
    
    - name: Upload binary artifact
      uses: actions/upload-artifact@v4
      with:
        name: bogowi-api-linux
        path: bogowi-api-linux
        retention-days: 1

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 30
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download binary artifact
      uses: actions/download-artifact@v4
      with:
        name: bogowi-api-linux
    
    - name: Generate version
      id: version
      run: |
        # Get current date and run number
        VERSION="1.0.$(date +%Y%m%d).${{ github.run_number }}"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Generated version: $VERSION"
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Install AWS CLI
      run: |
        if ! command -v aws &> /dev/null; then
          echo "Installing AWS CLI..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          sudo ./aws/install
        else
          echo "AWS CLI already installed: $(aws --version)"
        fi
    
    - name: Debug Connection
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      run: |
        echo "Testing connection to EC2_HOST..."
        echo "Host value (masked): ${EC2_HOST:0:5}...${EC2_HOST: -5}"
        echo "Instance ID: $EC2_INSTANCE_ID"
        
        # If EC2_HOST is empty, try to get it from instance ID
        if [ -z "$EC2_HOST" ] && [ ! -z "$EC2_INSTANCE_ID" ]; then
          echo "EC2_HOST not set, fetching from instance ID..."
          EC2_HOST=$(aws ec2 describe-instances --instance-ids $EC2_INSTANCE_ID --region ${{ env.AWS_REGION }} --query 'Reservations[0].Instances[0].PublicDnsName' --output text)
          echo "Resolved EC2_HOST: ${EC2_HOST:0:5}...${EC2_HOST: -5}"
        fi
        
        # Test DNS resolution
        echo "Testing DNS resolution..."
        nslookup $EC2_HOST || echo "DNS lookup failed"
        
        # Test connectivity
        echo "Testing SSH connectivity..."
        timeout 10 nc -zv $EC2_HOST 22 2>&1 || echo "Port 22 connection test failed"
    
    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
        EC2_KEY: ${{ secrets.EC2_KEY }}
      run: |
        # Resolve EC2_HOST if not set
        if [ -z "$EC2_HOST" ] && [ ! -z "$EC2_INSTANCE_ID" ]; then
          echo "Resolving EC2_HOST from instance ID..."
          EC2_HOST=$(aws ec2 describe-instances --instance-ids $EC2_INSTANCE_ID --region ${{ env.AWS_REGION }} --query 'Reservations[0].Instances[0].PublicDnsName' --output text)
          echo "Using EC2_HOST: $EC2_HOST"
        fi
        
        # Validate EC2_HOST
        if [ -z "$EC2_HOST" ] || [ "$EC2_HOST" = "None" ]; then
          echo "ERROR: Could not determine EC2_HOST"
          exit 1
        fi
        
        # Create SSH key file
        echo "$EC2_KEY" > ec2_key.pem
        chmod 600 ec2_key.pem
        
        # Test SSH connection first
        echo "Testing SSH connection..."
        ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 \
            -i ec2_key.pem $EC2_USERNAME@$EC2_HOST \
            "echo 'SSH connection successful'" || {
          echo "SSH connection failed. Checking instance status..."
          aws ec2 describe-instance-status --instance-ids $EC2_INSTANCE_ID --region ${{ env.AWS_REGION }}
          exit 1
        }
        
        # Make binary executable
        chmod +x bogowi-api-linux
        
        # Create deployment script with version
        VERSION="${{ steps.version.outputs.version }}"
        cat > deploy.sh << SCRIPT
        #!/bin/bash
        set -e
        
        echo "=== Starting BOGOWI Go API Deployment ==="
        echo "Timestamp: $(date)"
        
        # Navigate to home directory
        cd /home/ec2-user
        
        # Stop service before replacing binary
        echo "Stopping API service..."
        sudo systemctl stop bogowi-api || true
        
        # Deploy new API binary
        echo "Deploying new API binary..."
        sudo cp /tmp/bogowi-api-linux /usr/local/bin/bogowi-api
        sudo chmod +x /usr/local/bin/bogowi-api
        
        # Update build info
        echo "Updating build info..."
        echo '{
          "version": "'${VERSION}'",
          "build_date": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
          "last_commit": "'${{ github.sha }}'",
          "commit_message": '"$(echo "${{ github.event.head_commit.message }}" | sed 's/"/\\"/g' | head -1)"',
          "branch": "'${{ github.ref_name }}'",
          "build_number": '${{ github.run_number }}'
        }' | sudo tee /var/www/html/build-info.json
        
        # Restart API service
        echo "Restarting API service..."
        sudo systemctl restart bogowi-api
        
        # Check API status
        echo "Checking API status..."
        sleep 2
        sudo systemctl status bogowi-api
        
        # Health check
        echo "Running health check..."
        for i in {1..30}; do
          if curl -f -m 5 http://localhost:3001/api/health; then
            echo "✅ API is healthy!"
            break
          fi
          echo "Waiting for API... ($i/30)"
          sleep 2
        done
        
        # Final verification
        if ! curl -f http://localhost:3001/api/health; then
          echo "❌ Health check failed!"
          sudo journalctl -u bogowi-api -n 50
          exit 1
        fi
        SCRIPT
        
        # Copy binary first, then deployment script
        echo "Copying binary to EC2..."
        scp -o StrictHostKeyChecking=no \
            -o ServerAliveInterval=30 \
            -o ServerAliveCountMax=120 \
            -o ConnectTimeout=300 \
            -i ec2_key.pem bogowi-api-linux $EC2_USERNAME@$EC2_HOST:/tmp/
        
        echo "Copying deployment script to EC2..."
        scp -o StrictHostKeyChecking=no \
            -o ServerAliveInterval=30 \
            -o ServerAliveCountMax=120 \
            -o ConnectTimeout=300 \
            -i ec2_key.pem deploy.sh $EC2_USERNAME@$EC2_HOST:/tmp/
        
        # Execute deployment script
        echo "Executing deployment script..."
        ssh -o StrictHostKeyChecking=no \
            -o ServerAliveInterval=30 \
            -o ServerAliveCountMax=120 \
            -o ConnectTimeout=300 \
            -o TCPKeepAlive=yes \
            -i ec2_key.pem $EC2_USERNAME@$EC2_HOST \
            'bash /tmp/deploy.sh 2>&1 | tee /tmp/deploy.log'
        
        # Cleanup
        rm -f ec2_key.pem deploy.sh
    
    - name: Verify Deployment
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      run: |
        # Resolve EC2_HOST if not set
        if [ -z "$EC2_HOST" ] && [ ! -z "$EC2_INSTANCE_ID" ]; then
          EC2_HOST=$(aws ec2 describe-instances --instance-ids $EC2_INSTANCE_ID --region ${{ env.AWS_REGION }} --query 'Reservations[0].Instances[0].PublicDnsName' --output text)
        fi
        
        # Wait a bit more for the service to stabilize
        sleep 10
        
        # Check if the API is accessible via domain
        max_attempts=5
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Checking API health via domain (attempt $attempt/$max_attempts)..."
          if curl -k -f -m 10 https://web3.bogowi.com/api/health; then
            echo "✅ API is running successfully via domain!"
            exit 0
          fi
          echo "API not ready yet via domain, trying direct connection..."
          
          # Try direct connection to EC2 instance
          if curl -f -m 10 http://$EC2_HOST:3001/api/health; then
            echo "✅ API is running successfully on EC2!"
            echo "Note: Domain might need DNS propagation time"
            exit 0
          fi
          
          echo "API not ready yet, waiting..."
          sleep 10
          attempt=$((attempt + 1))
        done
        
        echo "❌ API health check failed after $max_attempts attempts"
        exit 1
